#include<curses.h>

#include"field.h"

int check[4] = {};
int H = 20, W = 12; //размер игрового поля
int Xfo = 10, Yfo = 2; // координаты верхнего угла игрового поля

// массив, описывающий начальное значение поля:
int Start_Field[22][12] = {{1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,0,0,0,0,0,0,0,0,0,0,1},
                           {1,1,1,1,1,1,1,1,1,1,1,1},
                           {1,1,1,1,1,1,1,1,1,1,1,1}};

int Curent_Field[22][12];

// функция отрисовки игрового поля
void print_field(int *mass)
{
    for(int i = 0; i < H; ++i)
    {
        for(int j = 1; j < W - 1; ++j)
        {
            if (mass[W * i + j])
            {
                attron(COLOR_PAIR(5));
                mvvline(Yfo + i, 10 + j, 8, 1);
                attroff(COLOR_PAIR(5));
            }
            else
               mvvline(Yfo + i, Xfo + j, 0x0020, 1);
        }
    }
};



//функция проверки полных линий
   //возвращает их количество и записывает в массив check номера полных линий.
int check_field(int *field,int check[])
{
    int S, k = 0;
    for(int i = 0; i < H; ++i)
    {
        S = 0;
        for(int j = 1; j < W - 1; ++j)
            S += field[W * i + j];
        if (S == 10)
        {
            check[k] = i;
            ++k;
        }
    }
    return k;
}

//мигает полными линиями 3 раза и перезаписывает массив игрового поля, исключая заполненные поля
void crash_lines(int *field, int *check, int K)
{
    for(int n = 0; n < 3; ++n)
    {
        for(int i = 0; i < K; ++i)
            mvhline(Yfo + check[i], Xfo + 1, 0x0020, 10);
        refresh();
        napms(100);
        attron(COLOR_PAIR(5));
        for(int i = 0; i < K; ++i)
            mvhline(Yfo + check[i], Xfo + 1, 8, 10);
        attroff(COLOR_PAIR(5));
        refresh();
        napms(100);
    }
    for(int n = 0; n < K; ++n)
    {
        for(int i = check[n]; i >= 1; --i)
            for(int j = 1; j < W - 1; ++j)
                field[W * i + j] = field[W * (i - 1) + j];
    }
};
